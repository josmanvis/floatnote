---
phase: 05-layers-and-layer-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/renderer.js]
autonomous: true

must_haves:
  truths:
    - "New drawings/shapes/text are added to the currently active layer"
    - "Layer state persists across app restarts (saved with note data)"
    - "Existing saved notes without layers load correctly with all data intact"
    - "Undo/redo captures and restores full layer state"
    - "Shape selection works when clicking inside filled shape area (in both draw and select modes)"
  artifacts:
    - path: "src/renderer.js"
      provides: "Layer data model, migration, getters, undo/redo, cross-layer rendering and selection"
      contains: "getActiveLayer|migrateNoteToLayers|findObjectAtPointAcrossLayers"
  key_links:
    - from: "this.lines getter"
      to: "getActiveLayer().lines"
      via: "active layer delegation"
      pattern: "getActiveLayer\\(\\)"
    - from: "saveState()"
      to: "note.layers"
      via: "deep clone of layers array"
      pattern: "JSON\\.parse.*note\\.layers"
    - from: "loadSavedData()"
      to: "migrateNoteToLayers()"
      via: "migration on load"
      pattern: "migrateNoteToLayers"
---

<objective>
Implement the core layer data model, migrate existing notes, rewire getters/setters to delegate to active layer, update undo/redo to snapshot layers, update redraw() to render all visible layers in order, and fix shape selection (fill-area hit testing works in all modes, cross-layer search).

Purpose: This is the foundation that all layer UI and controls depend on. Without the data model and rendering changes, the layer panel has nothing to control.
Output: A working layer system under the hood -- existing functionality preserved, new notes get a default layer, old notes migrated, rendering uses layer order.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-layers-and-layer-management/05-RESEARCH.md
@src/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Layer data model, migration, and getter/setter rewiring</name>
  <files>src/renderer.js</files>
  <action>
1. Add a `migrateNoteToLayers(note)` method to the Glassboard class:
   - If `note.layers` already exists, return the note unchanged
   - Otherwise, create a default layer object: `{ id: 'layer-' + (note.id || Date.now()), name: 'Layer 1', visible: true, locked: false, lines: note.lines || [], textItems: note.textItems || [], images: note.images || [] }`
   - Set `note.layers = [defaultLayer]`, `note.activeLayerId = defaultLayer.id`
   - Delete `note.lines`, `note.textItems`, `note.images` from the note (use `delete`)
   - Return the modified note

2. Add a `getActiveLayer()` method:
   - Gets current note: `this.notes[this.currentNoteIndex]`
   - If no note or no `note.layers`, return null
   - Find layer with `id === note.activeLayerId`
   - Fallback to `note.layers[0]` if active not found
   - Return the layer object

3. Add an `isActiveLayerLocked()` method:
   - Returns `this.getActiveLayer()?.locked || false`

4. Rewire the getters and setters for `lines`, `textItems`, `images`:
   - `get lines()` -> `return this.getActiveLayer()?.lines || []`
   - `set lines(value)` -> `const layer = this.getActiveLayer(); if (layer) layer.lines = value;`
   - Same pattern for `textItems` and `images`
   - Keep `attachments` getter/setter unchanged (attachments stay at note level)

5. Update `createEmptyNote()`:
   - Instead of `lines: [], textItems: [], images: []` at top level, create with:
     ```
     const layerId = 'layer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
     ```
   - Add `layers: [{ id: layerId, name: 'Layer 1', visible: true, locked: false, lines: [], textItems: [], images: [] }]`
   - Add `activeLayerId: layerId`
   - Remove the flat `lines`, `textItems`, `images` properties

6. Update `loadSavedData()`:
   - After loading notes from `data.notes`, iterate and migrate each: `this.notes = this.notes.map(n => this.migrateNoteToLayers(n))`
   - For legacy single-note format migration (the `else if (data.lines || ...)` block), also wrap in layers format after creating the note object
   - For clean-slate path: also migrate notes before pushing the empty note

7. Update `saveState()`:
   - Change the state snapshot to capture the full layers array:
     ```
     const note = this.notes[this.currentNoteIndex];
     const state = {
         layers: JSON.parse(JSON.stringify(note.layers)),
         activeLayerId: note.activeLayerId
     };
     ```

8. Update `restoreState(state)`:
   - Set `note.layers = JSON.parse(JSON.stringify(state.layers))`
   - Set `note.activeLayerId = state.activeLayerId`
   - Clear all text items and images from DOM
   - Iterate ALL layers and restore their textItems and images (pass layerId to restoreTextItem/restoreImage for data-layer-id attribute)
   - Call `this.redraw()`

9. Update `restoreTextItem(item, layerId)` to accept optional layerId parameter:
   - Add `element.dataset.layerId = layerId || ''` after creating the element
   - Keep all existing logic unchanged

10. Update `restoreImage(img, layerId)` similarly:
    - Add `element.dataset.layerId = layerId || ''`

11. Update `loadCurrentNote()`:
    - Instead of `note.textItems.forEach(...)` and `note.images.forEach(...)`, iterate ALL layers:
      ```
      note.layers.forEach(layer => {
          if (layer.visible) {
              layer.textItems.forEach(item => this.restoreTextItem(item, layer.id));
              layer.images.forEach(img => this.restoreImage(img, layer.id));
          }
      });
      ```

12. Add locked layer guards at the start of these methods/event handlers:
    - In `startDrawing`: after `if (this.isTextMode) return;`, add `if (this.isActiveLayerLocked()) return;`
    - In the text creation handler (where new text items are created): add locked check
    - In paste handler: add locked check before pasting

  </action>
  <verify>
Run `npm test` to ensure existing tests still pass. The app should still function identically since all data flows through the same getters/setters and the migration creates the same structure.
  </verify>
  <done>
- getActiveLayer() returns the correct layer object
- Getters delegate to active layer's arrays
- createEmptyNote() produces a note with layers array
- loadSavedData() migrates old format notes to layers format
- saveState/restoreState work with layers array
- Locked layer check exists (though no UI to toggle it yet)
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-layer rendering and cross-layer shape selection fix</name>
  <files>src/renderer.js</files>
  <action>
1. Update `redraw()` method to render all visible layers in order:
   ```javascript
   redraw() {
       const rect = this.canvas.getBoundingClientRect();
       this.ctx.clearRect(0, 0, rect.width / this.zoomLevel, rect.height / this.zoomLevel);
       this.drawCenterDot();

       const note = this.notes[this.currentNoteIndex];
       if (!note || !note.layers) return;

       // Draw all visible layers in order (index 0 = bottom)
       note.layers.forEach(layer => {
           if (!layer.visible) return;
           layer.lines.forEach(line => this.drawLine(line));
       });

       // Draw current line (always on top during active drawing)
       if (this.currentLine) {
           this.drawLine(this.currentLine);
       }

       // Draw selection highlights
       if (this.selectedObjectId) {
           this.drawSelectionHighlight();
       }
       if (this.multiSelectedObjects.length > 0) {
           this.multiSelectedObjects.forEach(objectId => {
               this.drawSelectionHighlightForObject(objectId);
           });
       }
       if (this.allSelected && this.selectedObjects.length > 0) {
           this.selectedObjects.forEach(objectId => {
               this.drawSelectionHighlightForObject(objectId);
           });
       }
   }
   ```

2. Add `getAllVisibleLines()` method:
   - Returns all lines from all visible layers (for hit-testing/selection):
     ```javascript
     getAllVisibleLines() {
         const note = this.notes[this.currentNoteIndex];
         if (!note || !note.layers) return [];
         const allLines = [];
         note.layers.forEach(layer => {
             if (layer.visible) {
                 allLines.push(...layer.lines);
             }
         });
         return allLines;
     }
     ```

3. Add `findLayerForObject(objectId)` method:
   - Searches all visible layers for the object and returns the layer ID:
     ```javascript
     findLayerForObject(objectId) {
         const note = this.notes[this.currentNoteIndex];
         if (!note || !note.layers) return null;
         for (const layer of note.layers) {
             if (!layer.visible) continue;
             if (layer.lines.some(l => l.objectId === objectId)) return layer.id;
         }
         return null;
     }
     ```

4. FIX shape selection bug AND update `findObjectAtPoint()` to search across all visible layers:
   - Replace the current implementation that only searches `this.lines` (active layer)
   - Search across `getAllVisibleLines()` instead
   - CRITICAL FIX: Remove the `this.isSelectMode &&` condition from the `isPointInsideShape` check. Shape fill-area clicking should work in ALL modes (draw mode too), not just select mode. This is the shape selection bug.
   - When a match is found on a non-active layer, auto-switch active layer: `note.activeLayerId = layerId`
   - Updated method:
     ```javascript
     findObjectAtPoint(point) {
         const hitRadius = 10;
         const note = this.notes[this.currentNoteIndex];
         if (!note || !note.layers) return null;

         // Search layers in reverse order (top layer = last in array)
         for (let li = note.layers.length - 1; li >= 0; li--) {
             const layer = note.layers[li];
             if (!layer.visible || layer.locked) continue;

             for (let i = layer.lines.length - 1; i >= 0; i--) {
                 const line = layer.lines[i];

                 // Check fill-area for closed shapes (works in all modes)
                 if (this.isPointInsideShape(point, line)) {
                     // Auto-switch to this layer if not active
                     if (note.activeLayerId !== layer.id) {
                         note.activeLayerId = layer.id;
                         if (this.updateLayerPanel) this.updateLayerPanel();
                     }
                     return line.objectId;
                 }

                 // Point proximity to stroke
                 for (const p of line.points) {
                     const dist = Math.sqrt((p.x - point.x) ** 2 + (p.y - point.y) ** 2);
                     if (dist < hitRadius + line.width / 2) {
                         if (note.activeLayerId !== layer.id) {
                             note.activeLayerId = layer.id;
                             if (this.updateLayerPanel) this.updateLayerPanel();
                         }
                         return line.objectId;
                     }
                 }
             }
         }
         return null;
     }
     ```

5. Update `getObjectBounds()` to search across all visible layers:
   - Instead of `this.lines.filter(...)`, use `this.getAllVisibleLines().filter(...)`

6. Update `moveObject()` to work across all visible layers:
   - Instead of iterating `this.lines`, iterate `getAllVisibleLines()`

7. Update `drawSelectionHighlight()` and `drawSelectionHighlightForObject()` to use `getAllVisibleLines()` for finding object lines

8. Update DOM visibility when layers are toggled (preparation for panel):
   - Add `updateDOMVisibility()` method that shows/hides text items and images based on their layer's visibility:
     ```javascript
     updateDOMVisibility() {
         const note = this.notes[this.currentNoteIndex];
         if (!note || !note.layers) return;
         note.layers.forEach(layer => {
             const display = layer.visible ? '' : 'none';
             this.textContainer.querySelectorAll(`[data-layer-id="${layer.id}"]`).forEach(el => {
                 el.style.display = display;
             });
         });
     }
     ```

9. When creating new text items or pasting images, add `data-layer-id` attribute set to the active layer's ID.
  </action>
  <verify>
Run `npm test`. Manually verify (if running the app) that:
- Drawing a shape and clicking inside it in draw mode selects it (bug fix)
- Objects on different layers are all rendered
- Clicking an object auto-switches to its layer
  </verify>
  <done>
- redraw() renders all visible layers in order
- findObjectAtPoint() searches all visible, unlocked layers
- Shape fill-area hit testing works in all modes (not just select mode) -- bug fixed
- Clicking object on non-active layer auto-switches active layer
- DOM elements have data-layer-id for visibility management
- getObjectBounds/moveObject work across layers
  </done>
</task>

</tasks>

<verification>
- `npm test` passes (all existing tests)
- New notes have `layers` array with one default layer
- Old notes (without layers) get migrated on load
- Undo/redo captures full layer state
- Shape selection works by clicking inside filled shapes in any mode
- All visible layers render in correct order
</verification>

<success_criteria>
- Layer data model is the source of truth for all note content
- Backward-compatible: existing saved data loads without data loss
- Shape selection bug is fixed (clicking inside shape fill area works in draw mode)
- Rendering respects layer visibility and order
- Foundation is solid for layer panel UI (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/05-layers-and-layer-management/05-01-SUMMARY.md`
</output>
