---
phase: 02-e2e-tests
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tests/e2e/persistence.spec.js
  - tests/e2e/settings.spec.js
autonomous: true

must_haves:
  truths:
    - "E2E test draws content, restarts the app, and verifies the content survives the restart"
    - "E2E test changes a setting, restarts the app, and verifies the setting persists"
    - "E2E test creates multiple notes with content, restarts, and all notes survive"
  artifacts:
    - path: "tests/e2e/persistence.spec.js"
      provides: "Save/load persistence across restart E2E test (TEST-06)"
      contains: "restart"
    - path: "tests/e2e/settings.spec.js"
      provides: "Settings persistence E2E test (TEST-08)"
      contains: "setting-pinch-zoom"
  key_links:
    - from: "tests/e2e/persistence.spec.js"
      to: "electron.launch (second time)"
      via: "Close app, relaunch with same tmpDir to verify data survives"
      pattern: "electron\\.launch"
    - from: "tests/e2e/settings.spec.js"
      to: "settings panel inputs"
      via: "Toggle settings, restart, verify inputs retain state"
      pattern: "setting-pinch-zoom|setting-pan"
    - from: "tests/e2e/persistence.spec.js"
      to: "floatnote-data.json in tmpDir"
      via: "Auto-save writes data file, second launch reads it"
      pattern: "waitForTimeout.*1500"
---

<objective>
Implement E2E tests for data persistence and settings survival across app restarts.

Purpose: Covers TEST-06 (save/load persistence) and TEST-08 (settings persistence). These tests are unique because they require closing and relaunching the Electron app with the same userData directory, verifying the data file survives the round-trip.

Output: Two test files that prove data and settings survive app restarts, using manual Electron launch/close cycles with shared temp directories.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/2/RESEARCH.md
@src/main.js
@src/renderer.js
@src/index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Data persistence across restart tests</name>
  <files>tests/e2e/persistence.spec.js</files>
  <action>
    Create `tests/e2e/persistence.spec.js`:

    These tests CANNOT use the shared fixture because they need to control the app lifecycle (close and relaunch). They manage their own Electron launch/close cycles.

    - Import `{ test: base, expect, _electron: electron }` from `@playwright/test`
    - Import `{ stubDialog }` from `electron-playwright-helpers`
    - Import `path`, `fs`, `os`

    - Helper function `launchApp(tmpDir)`:
      ```javascript
      async function launchApp(tmpDir) {
        const app = await electron.launch({
          args: [path.join(__dirname, '../../src/main.js')],
          env: {
            ...process.env,
            ELECTRON_USER_DATA_DIR: tmpDir,
            NODE_ENV: 'test'
          }
        });
        await stubDialog(app, 'showMessageBox', { response: 0 });
        const page = await app.firstWindow();
        await page.waitForSelector('#draw-canvas');
        return { app, page };
      }
      ```

    - Helper function `drawStroke(page, startX, startY, endX, endY)`:
      Same as in drawing.spec.js - gets boundingBox, does mouse down/move/up with 10 steps.

    - Helper function `waitForAutoSave(page)`:
      `await page.waitForTimeout(2000);` (1s debounce + 1s buffer for CI)

    - Test: "drawing persists across app restart"
      - Create tmpDir
      - Launch app (session 1)
      - Click `#draw-mode`
      - Draw a stroke (100,100 -> 300,300)
      - Call waitForAutoSave
      - Close: `await app.close()`
      - Brief delay: `await new Promise(r => setTimeout(r, 500))`
      - Launch app (session 2) with same tmpDir
      - Wait for data load: `await page.waitForTimeout(500)`
      - Verify: `page.evaluate(() => window.glassboardInstance.lines.length)` > 0
      - Also verify line has points: `page.evaluate(() => window.glassboardInstance.lines[0].points.length)` > 2
      - Close session 2
      - Cleanup tmpDir

    - Test: "text items persist across restart"
      - Create tmpDir
      - Launch session 1
      - Switch to text mode, create text item, type 'Persistent text'
      - Click elsewhere to deselect
      - waitForAutoSave
      - Close session 1
      - Launch session 2 with same tmpDir
      - Wait for load
      - Verify: `textItems.length` === 1
      - Verify: `textItems[0].content` contains 'Persistent text'
      - Close, cleanup

    - Test: "multiple notes persist across restart"
      - Create tmpDir
      - Launch session 1
      - Draw on note 1
      - Click `#new-note` to create note 2
      - Draw on note 2
      - waitForAutoSave
      - Close session 1
      - Launch session 2 with same tmpDir
      - Wait for load
      - Verify note count: `page.evaluate(() => window.glassboardInstance.notes.length)` === 2
      - Verify note 1 has lines: navigate to note 1 and check
      - Close, cleanup

    WRAP each test in try/finally with `fs.rmSync(tmpDir, { recursive: true, force: true })` in the finally block.

    IMPORTANT: After closing session 1, wait 500ms before relaunching. The single-instance lock may take a moment to release even with NODE_ENV=test (the lock skip is in our main.js modification).

    IMPORTANT: After launching session 2, wait 500ms for loadSavedData to complete (it's called during initialization and reads from disk).
  </action>
  <verify>
    Run `npx playwright test persistence.spec.js` and all 3 tests pass. Verify by checking test output shows data surviving restart.
  </verify>
  <done>
    Drawing, text, and multi-note data all verified to survive app restart via auto-save. TEST-06 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings persistence across restart tests</name>
  <files>tests/e2e/settings.spec.js</files>
  <action>
    Create `tests/e2e/settings.spec.js`:

    Same pattern as persistence.spec.js - manual app lifecycle, no shared fixture.

    - Import same deps as persistence.spec.js
    - Reuse `launchApp`, `waitForAutoSave` helpers (or import from a shared module if DRY is worth it - but duplicating is fine for 2 files)

    - Test: "gesture settings persist across restart"
      - Create tmpDir, launch session 1
      - Open settings: `await page.keyboard.press('Meta+,')`
      - Wait for settings panel: `await page.waitForSelector('#settings-panel', { state: 'visible' })`
      - Uncheck pinch-zoom: `await page.locator('#setting-pinch-zoom').uncheck()`
      - Uncheck pan: `await page.locator('#setting-pan').uncheck()`
      - Close settings panel: `await page.click('#settings-close')`
      - waitForAutoSave
      - Close session 1, wait 500ms
      - Launch session 2 with same tmpDir
      - Wait for load (500ms)
      - Open settings again
      - Verify `#setting-pinch-zoom` is NOT checked: `expect(await page.locator('#setting-pinch-zoom').isChecked()).toBe(false)`
      - Verify `#setting-pan` is NOT checked
      - Verify `#setting-rotate` IS still checked (wasn't changed)
      - Close, cleanup

    - Test: "appearance settings persist across restart"
      - Create tmpDir, launch session 1
      - Open settings
      - Change active opacity slider: `await page.locator('#setting-active-opacity').fill('50')` (or use page.evaluate to set the value and trigger input event)
        NOTE: Range inputs in Playwright: use `page.locator('#setting-active-opacity').fill('50')` which sets the value. But the app may listen for 'input' event, so also dispatch it:
        ```javascript
        await page.evaluate(() => {
          const slider = document.getElementById('setting-active-opacity');
          slider.value = '50';
          slider.dispatchEvent(new Event('input', { bubbles: true }));
        });
        ```
      - Close settings
      - waitForAutoSave
      - Close session 1, wait 500ms
      - Launch session 2 with same tmpDir
      - Wait for load
      - Verify slider value: `page.evaluate(() => document.getElementById('setting-active-opacity').value)` === '50'
      - Close, cleanup

    - Test: "behavior settings persist across restart"
      - Create tmpDir, launch session 1
      - Open settings
      - Check "Always open with clean slate": `await page.locator('#setting-clean-slate').check()`
      - Close settings
      - waitForAutoSave
      - Close session 1, wait 500ms
      - Launch session 2 with same tmpDir
      - Wait for load
      - Open settings
      - Verify `#setting-clean-slate` IS checked
      - Close, cleanup

    IMPORTANT: Settings are saved as part of the auto-save (same data file). The settings values are stored in the data JSON and restored on load. Verify by checking the actual DOM state of the inputs after restart, not just the data model, since this proves the full load path works.
  </action>
  <verify>
    Run `npx playwright test settings.spec.js` and all 3 tests pass. Each test verifies a different settings category survives restart.
  </verify>
  <done>
    Gesture, appearance, and behavior settings all verified to persist across app restart. TEST-08 satisfied.
  </done>
</task>

</tasks>

<verification>
- `npx playwright test persistence.spec.js` passes (3 tests: drawing, text, multi-note persistence)
- `npx playwright test settings.spec.js` passes (3 tests: gesture, appearance, behavior settings)
- Each test uses isolated tmpDir, no cross-test contamination
- Auto-save wait (2000ms) prevents flaky failures
- Session relaunch delay (500ms) prevents lock conflicts
- `npx playwright test` runs ALL e2e tests (from all 3 plans) and passes
</verification>

<success_criteria>
- Data drawn/typed in session 1 is verified present in session 2 (TEST-06)
- Settings changed in session 1 are verified persisted in session 2 (TEST-08)
- No flaky failures from timing (auto-save debounce handled)
- No failures from instance lock conflicts (delay between close/relaunch)
- Full `npx playwright test` suite passes: drawing + text + multi-note + clipboard + persistence + settings
</success_criteria>

<output>
After completion, create `.planning/phases/2/02-03-SUMMARY.md`
</output>
