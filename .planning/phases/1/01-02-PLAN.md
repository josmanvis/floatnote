---
phase: 01-integration-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/integration/preload-bridge.test.js
autonomous: true

must_haves:
  truths:
    - "Preload exposes all 14 methods renderer.js actually calls via window.glassboard, and exposes no extra unused methods"
    - "IPC channel names in preload.js exactly match registered handlers/listeners in main.js"
    - "send-type methods (closeWindow, hideWindow, setPinned, setWindowSize, resizeWindowLeft, openFile) call ipcRenderer.send with correct channel"
    - "invoke-type methods (saveData, loadData, exportToFloatnote, openFloatnoteFolder, exportPNG) call ipcRenderer.invoke with correct channel"
    - "Listener methods (onFocusChange, onWindowToggledOpen) register ipcRenderer.on callbacks"
    - "Clipboard methods (getClipboardContent, readClipboardImage, readClipboardText) access clipboard directly without IPC"
    - "Arguments are passed through correctly (setPinned passes boolean, saveData passes data object)"
  artifacts:
    - path: "tests/integration/preload-bridge.test.js"
      provides: "Preload bridge API contract verification tests"
      min_lines: 120
  key_links:
    - from: "tests/integration/preload-bridge.test.js"
      to: "src/preload.js"
      via: "require('../../src/preload.js') captures exposed API"
      pattern: "require.*src/preload"
    - from: "tests/integration/preload-bridge.test.js"
      to: "src/renderer.js"
      via: "programmatic grep for window.glassboard.* calls"
      pattern: "rendererSource|window\\.glassboard"
---

<objective>
Create integration tests that verify the preload bridge exposes all APIs renderer.js depends on, with correct IPC channel mappings and argument forwarding.

Purpose: Catch contract mismatches between preload.js and renderer.js -- methods renderer calls that preload does not expose, or channel names that do not match main.js handlers.

Output: `tests/integration/preload-bridge.test.js` with passing tests for all bridge methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/1/RESEARCH.md
@src/preload.js
@src/renderer.js
@jest.config.js
@tests/mocks/electron.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create preload bridge contract tests</name>
  <files>tests/integration/preload-bridge.test.js</files>
  <action>
Create `tests/integration/preload-bridge.test.js` that:

1. **Mocks electron inline** using jest.mock('electron') with:
   - `ipcRenderer.on` as jest.fn()
   - `ipcRenderer.send` as jest.fn()
   - `ipcRenderer.invoke` as jest.fn(() => Promise.resolve({success: true}))
   - `contextBridge.exposeInMainWorld` as jest.fn()
   - `clipboard.availableFormats` as jest.fn(() => [])
   - `clipboard.readImage` as jest.fn(() => ({isEmpty: jest.fn(() => true), toDataURL: jest.fn(() => ''), getSize: jest.fn(() => ({width: 0, height: 0}))}))
   - `clipboard.readText` as jest.fn(() => '')
   - `nativeImage` (if needed, but preload.js does not use it directly -- check import)

   Note: preload.js imports `{ contextBridge, ipcRenderer, clipboard, nativeImage }` from electron. Include nativeImage as a mock even if unused, to prevent require errors.

2. **Requires actual preload.js** after mocks:
   ```javascript
   require('../../src/preload.js');
   ```

3. **Extracts the exposed API:**
   ```javascript
   const exposedAPI = contextBridge.exposeInMainWorld.mock.calls[0][1];
   ```

4. **Tests these describe blocks:**

   **describe('API registration'):**
   - test: exposeInMainWorld is called with 'glassboard' as first arg
   - test: exposed API is an object (not null/undefined)

   **describe('API completeness - bidirectional contract verification'):**
   - Read `src/renderer.js` using `jest.requireActual('fs')` and extract all `window.glassboard.XXX` method names via regex `/window\.glassboard\.(\w+)/g`
   - For each extracted method name, verify `exposedAPI[methodName]` is defined and is a function
   - ALSO verify the reverse: for each key in exposedAPI, verify it appears in the renderer's extracted method set (catches unused/stale APIs in preload)
   - This is a bidirectional programmatic contract test: fails if renderer calls something preload doesn't expose, AND fails if preload exposes something renderer never calls

   **describe('IPC channel cross-verification - preload channels match main.js'):**
   - Read `src/main.js` using `jest.requireActual('fs')` and extract all IPC channel names from `ipcMain.handle('channel-name'` and `ipcMain.on('channel-name'` via regex
   - Read `src/preload.js` source and extract all channel names from `ipcRenderer.invoke('channel-name'` and `ipcRenderer.send('channel-name'` via regex
   - Verify every channel preload sends/invokes has a corresponding handler/listener in main.js
   - This catches channel name typos that would silently break the app at runtime

   **describe('send-type methods - fire and forget'):**
   - test: closeWindow() calls ipcRenderer.send('close-window') with no extra args
   - test: hideWindow() calls ipcRenderer.send('hide-window') with no extra args
   - test: setPinned(true) calls ipcRenderer.send('set-pinned', true)
   - test: setPinned(false) calls ipcRenderer.send('set-pinned', false)
   - test: setWindowSize('sm') calls ipcRenderer.send('set-window-size', 'sm')
   - test: setWindowSize('lg') calls ipcRenderer.send('set-window-size', 'lg')
   - test: resizeWindowLeft(50) calls ipcRenderer.send('resize-window-left', 50)
   - test: openFile('/path/to/file') calls ipcRenderer.send('open-file', '/path/to/file')

   **describe('invoke-type methods - request/response'):**
   - test: saveData({notes: []}) calls ipcRenderer.invoke('save-data', {notes: []})
   - test: loadData() calls ipcRenderer.invoke('load-data') with no extra args
   - test: exportToFloatnote({id: '1'}) calls ipcRenderer.invoke('export-to-floatnote', {id: '1'})
   - test: openFloatnoteFolder() calls ipcRenderer.invoke('open-floatnote-folder')
   - test: exportPNG('data:image/png;base64,abc') calls ipcRenderer.invoke('export-png', 'data:image/png;base64,abc')
   - test: all invoke methods return the Promise from ipcRenderer.invoke

   **describe('listener methods - event subscriptions'):**
   - test: onFocusChange(cb) registers ipcRenderer.on('window-focus', ...)
   - test: onFocusChange callback receives the focused boolean when triggered (invoke the registered callback with a mock event and true, verify cb was called with true)
   - test: onWindowToggledOpen(cb) registers ipcRenderer.on('window-toggled-open', ...)
   - test: onWindowToggledOpen callback fires when triggered

   **describe('clipboard methods - local access'):**
   - test: getClipboardContent() returns null when clipboard is empty
   - test: getClipboardContent() returns {type:'image', dataUrl, width, height} when image available (mock clipboard.availableFormats to return ['image/png'], clipboard.readImage to return non-empty image)
   - test: getClipboardContent() returns {type:'text', content} when text available (mock formats to ['text/plain'], readText to return 'hello')
   - test: readClipboardImage() returns dataUrl when image exists, null when empty
   - test: readClipboardText() returns clipboard text

5. **beforeEach** calls jest.clearAllMocks() but does NOT re-require preload.js (it only needs to be required once since the exposed API object is captured by reference).

   Actually -- since ipcRenderer.on/send/invoke are cleared, re-calling the API methods will still work because they call the mock functions fresh each time. The exposed API holds closures over the mock module references.

Key implementation notes:
- For the programmatic completeness test, use `const realFs = require('fs')` before any jest.mock calls, then read renderer.js source in the test. Jest's module mocking does not affect requires that happen before jest.mock().
- Actually in Jest, jest.mock is hoisted. So use `jest.requireActual('fs')` inside the test to get the real fs:
  ```javascript
  const realFs = jest.requireActual('fs');
  const rendererSource = realFs.readFileSync(path.join(__dirname, '../../src/renderer.js'), 'utf-8');
  ```
- The regex to extract methods: `/window\.glassboard\.(\w+)/g`
- Filter out duplicates using a Set
  </action>
  <verify>Run `npx jest --selectProjects=integration --testPathPattern=preload-bridge --verbose` and confirm all tests pass.</verify>
  <done>Preload bridge tests verify: (1) all methods renderer.js calls exist on the exposed API, (2) send methods map to correct IPC channels, (3) invoke methods map to correct IPC channels and pass args, (4) listener methods register on correct events, (5) clipboard methods access clipboard directly. No Electron window launched.</done>
</task>

<task type="auto">
  <name>Task 2: Verify full integration suite runs alongside existing tests</name>
  <files>tests/integration/ipc-handlers.test.js, tests/integration/preload-bridge.test.js</files>
  <action>
Run the complete test suite to verify integration tests work alongside existing tests:

1. Run `npx jest` (all projects) and confirm:
   - main project tests still pass
   - renderer project tests still pass
   - preload project tests still pass
   - cli project tests still pass (if any exist)
   - integration project tests pass (both files)

2. If any existing tests break due to the new jest.config.js entry, debug and fix. The integration project should be completely isolated since it uses its own testMatch pattern pointing to tests/integration/.

3. If the integration tests fail, debug by reading error output carefully:
   - "Cannot find module" -> check paths in require statements
   - "X is not a function" -> check mock completeness (main.js may call methods not yet mocked)
   - "handlers['x'] is undefined" -> main.js may not have registered that handler (check channel name spelling)
   - For main.js requiring 'path' module: path is a Node builtin and should work without mocking

This task is a verification-and-fix pass. If everything passes on first run, this task is done immediately.
  </action>
  <verify>Run `npx jest --verbose 2>&1 | tail -20` and confirm all test suites pass with 0 failures.</verify>
  <done>`npm test` exits 0 with all projects passing. Integration tests run alongside existing unit tests without interference.</done>
</task>

</tasks>

<verification>
1. `npx jest --selectProjects=integration` exits with code 0
2. `npx jest --selectProjects=integration --verbose 2>&1 | grep -c "PASS"` shows 2 (both test files)
3. `npx jest` (full suite) exits with code 0
4. The programmatic completeness test would fail if a new `window.glassboard.newMethod()` call were added to renderer.js without updating preload.js
</verification>

<success_criteria>
- Preload bridge contract tests verify all 14+ methods renderer.js calls
- Send-type methods verified to map to correct IPC channels with correct args
- Invoke-type methods verified to map to correct IPC channels with correct args
- Listener methods verified to register on correct event channels
- Clipboard methods verified to access clipboard directly (no IPC)
- Programmatic completeness test reads actual renderer.js source for future-proofing
- Full test suite (all projects) passes together
- No Electron window launched during tests
</success_criteria>

<output>
After completion, create `.planning/phases/1/01-02-SUMMARY.md`
</output>
